<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>World Strategy – Hex Nations</title>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>

<style>
html, body {
    margin: 0;
    padding: 0;
    background: #020617;
    overflow: hidden;
}
canvas {
    display: block;
}
#info {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    font-family: system-ui, sans-serif;
    padding: 8px 14px;
    border-radius: 8px;
}
</style>
</head>

<body>

<canvas id="map"></canvas>
<div id="info">Caricamento mappa…</div>

<script>
const canvas = document.getElementById("map");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// CAMERA
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let dragging = false;
let lastX = 0;
let lastY = 0;

// MAPPA
const projection = d3.geoMercator();
const path = d3.geoPath(projection, ctx);

let countries = [];
let hexes = [];
let selectedHex = null;

const HEX_SIZE = 10;

// COLORI NAZIONE
function nationColor(id) {
    let h = 0;
    for (let i = 0; i < id.length; i++) {
        h = id.charCodeAt(i) + ((h << 5) - h);
    }
    return `hsl(${h % 360},60%,45%)`;
}

// === LOAD WORLD ===
fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
.then(r => r.json())
.then(world => {
    countries = topojson.feature(world, world.objects.countries).features;

    projection.fitSize(
        [canvas.width, canvas.height],
        { type: "FeatureCollection", features: countries }
    );

    generateHexGrid();
    assignHexesToCountries();
    draw();

    info.textContent = "Mappa pronta – clicca un esagono";
});

// === HEX GRID ===
function generateHexGrid() {
    hexes = [];
    const w = canvas.width;
    const h = canvas.height;

    const dx = HEX_SIZE * Math.sqrt(3);
    const dy = HEX_SIZE * 1.5;

    for (let y = -HEX_SIZE; y < h + HEX_SIZE; y += dy) {
        for (let x = -HEX_SIZE; x < w + HEX_SIZE; x += dx) {
            const offset = (Math.round(y / dy) % 2) * dx / 2;
            hexes.push({
                x: x + offset,
                y,
                country: null
            });
        }
    }
}

// === ASSIGN NATION ===
function assignHexesToCountries() {
    hexes.forEach(h => {
        const lonLat = projection.invert([h.x, h.y]);
        if (!lonLat) return;

        for (let c of countries) {
            if (d3.geoContains(c, lonLat)) {
                h.country = c;
                break;
            }
        }
    });
}

// === DRAW ===
function draw() {
    ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
    ctx.clearRect(-offsetX/scale, -offsetY/scale, canvas.width/scale, canvas.height/scale);

    // oceano
    ctx.fillStyle = "#020617";
    ctx.fillRect(-10000,-10000,20000,20000);

    // hexes
    hexes.forEach(h => {
        drawHex(
            h.x,
            h.y,
            HEX_SIZE,
            h === selectedHex ? "#facc15" :
            h.country ? nationColor(h.country.id) : "#0f172a"
        );
    });
}

// === HEX DRAW ===
function drawHex(x, y, size, color) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 0.7;
    ctx.stroke();
}

// === INTERACTION ===
canvas.addEventListener("wheel", e => {
    e.preventDefault();
    scale *= e.deltaY < 0 ? 1.1 : 0.9;
    scale = Math.max(0.4, Math.min(8, scale));
    draw();
});

canvas.addEventListener("mousedown", e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
});

window.addEventListener("mouseup", () => dragging = false);

window.addEventListener("mousemove", e => {
    if (dragging) {
        offsetX += e.clientX - lastX;
        offsetY += e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        draw();
    }
});

canvas.addEventListener("click", e => {
    const mx = (e.offsetX - offsetX) / scale;
    const my = (e.offsetY - offsetY) / scale;

    selectedHex = null;
    for (let h of hexes) {
        if (Math.hypot(mx - h.x, my - h.y) < HEX_SIZE) {
            selectedHex = h;
            if (h.country) {
                info.textContent = `Nazione: ${h.country.id}`;
            } else {
                info.textContent = "Oceano";
            }
            break;
        }
    }
    draw();
});
</script>

</body>
</html>
